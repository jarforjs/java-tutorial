### 简单工厂模式只是解决对象的创建问题

### 策略模式Strategy
> 它定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。
1. 策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同。它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。
2. 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。
   > 对于打折、返利或者其他的算法，其实都是对实际商品收费的一种计算方式，通过继承，可以得到它们公共的功能——计算费用的结果GetResult，这使得算法之间有了抽象的父类CashSuper
3. 策略模式的有点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。
4. 当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消化条件语句。
   > 策略模式封装了变化！
5. 策略模式就是用封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同业务规则，就可以考虑使用策略模式处理这种变化的可能性。
6. 在基本的策略模式中，所择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。这本身并没有解除客户端需要选择判断的压力，而策略模式与简单工厂模式结合后，选择具体的职责也可以由Context来承担，这就最大化地减轻了客户端的职责。
   > 在CashContext里还是用到了switch，也就是说我们需要增加一种算法，就必须更改CashContext中的switch代码。想以最小的代价来完成这个需求的办法就是使用反射技术。

#### 聚合
一个类里面如果有另外一个类的引用，就可以称之为**聚合**
> 聚合aggregation关系：表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分

### Bridge
如果子类的扩展有两个维度，这个时候你想解耦合解决他们的排列组合问题


### 面试
java.io是什么设计模式？
Adapter，具体的类：InputStreamReader




















