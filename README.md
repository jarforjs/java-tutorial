# java tutorial

#### java除法的结果是取整还是正常值与被除数有关。
```
(11 + 3 * 8) / 4 % 3) = 2;
// java除法的结果是取整还是正常值与被除数有关。
(11 + 3 * 8) / 4.0 % 3 = 2.75;
```

#### java的for in循环
`for (int score : scores)`

#### java创建数组
```
// 定义一个长度为5的字符串数组
String[] subjects = new String[5];

// 等价于：
String[] subjects1 = new String[]{ "Oracle", "PHP", "Linux", "Java", "HTML" };

// 等价于：
String[] subjects2 = { "Oracle", "PHP", "Linux", "Java", "HTML" };
```

#### java中定义二维数组
```
// 定义一个两行三列的二维数组并赋值
String [][] arrays = new String[2][3];
String [][] names = {{"tom","jack","mike"},{"zhangsan","lisi","wangwu"}};
```

#### 强制类型转换
`numbers[i] = (int)(Math.random() * 100);`

#### for循环中i--的写法
`for (int i = scores.length - 1; i >= 0 && count < 4; i--) {}`

## 类
- 类是模子,是用来描述对象将会拥有的特征(属性)和行为(方法).

### 类的特点:
- 类是对象(具体数据信息比如手机)的类型
- 具有相同属性和方法的一组对象的集合

### 类和对象的关系
- 类是抽象的概念,它只是我们脑海里的想象,其实客观是不存在的,仅仅是模板而已.
- 对象是一个你能够看的到,摸得着的具体实体,是客观存在的.

### 创建对象
定义：`类名 对象名 = new 类名();`
- 引用对象的属性：对象名.属性
`phone.screen = 5;// 给screen属性赋值5`
- 引用对象的方法：对象名.方法
`phone.call()`

### 给float型变量赋值时必须加f，不然会认为时double型

### 成员变量局部变量区别
1. 作用域不同
   - 局部变量的作用域仅限于定义它的方法
   - 成员变量的作用域在整个类内部都是可见的
2. 初始值不同
   - java会给成员变量一个初始值
   - java不会给局部变量赋予初始值
3. 同一个方法不允许有同名局部变量，不同方法中可以有同名局部变量
4. 两类变量同名时，局部变量具有更高的优先级

### 构造方法
定义:`public 类名(){}`
#### 无参
- 平常创建对象我门一般都new一个类，实际上这个说法不严谨，我们new的实际是一个构造方法
   >定义：`Telephone phone = new Telephone()`
- 如果我们没有指定一个无参的构造方法，系统会自动给我们自动生成一个构造方法，如果我们对系统生成的无参构造方法不满意，可以自定义一个构造方法

#### 有参
- 有参的构造方法也可以创建对象，还可以给对象中的实例变量赋初始值

### 静态变量
- 静态变量可以直接使用类名访问

### 静态方法
- 静态方法可以直接使用类名访问
- 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。

  如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。
- 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量
- 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。

### 静态初始化块
- 静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。
- 通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 staticBlock1 时并未执行静态初始化块。

### 封装的步骤
1. 修改属性的可见性：设为private
2. 创建getter/setter方法（属性的读写）
3. 在getter/setter方法中加入属性控制语句进行合法性判断
> 封装就是隐藏属性，通过方法来设置获得属性

### 包
定义：`package 包名`
- 必须放在Java源程序的第一行，包名间可以使用'.'号隔开
- 包的使用可以通过import关键字，在某个文件夹中使用其他文件夹中的类
   >`import com.imooc.music.MyClass`
- Java包的命名规范是全小写
   
   使用的时候不但可以加载某个包下所有的文件
   >`eg：com.imooc.*`
   
   也可以加载某个具体子包下的所有文件
   >`eg：com.imooc.music.*`

### 访问修饰符
访问修饰符 | 本类 | 同包 | 子类 | 其他
--- | :---: | :---: | :---: | :---:
private | ✓ | | |
默认 |  ✓ | ✓ | | |
protected | ✓ | ✓ | ✓ |
public | ✓ | ✓ | ✓ | ✓

### 内部类的主要作用如下：
1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便

#### 内部类可分为以下几种：
> 成员内部类

> 静态内部类

>方法内部类

> 匿名内部类。

### 成员内部类

定义:`内部类 对象名 = 外部类对象.new 内部类( );`

注意:

1.外部类是不能直接使用内部类的成员和方法

得先创建外部类的对象,在对象.new 外部类()创建内部类,这样创建的内部类才能在外部类中的方法中使用或者访问内部类的成员变量和方法

`外部类 对象名 = new 外部类();`

`内部类 对象名 = 外部类.new 内部类();`

2.如果外部类和内部类具有相同的成员变量或方法,内部类默认访问自己的成员变量和方法,如果想访问外部类的成员变量,可以使用this关键字

`Outer.this.name`

### 静态内部类是 static 修饰的内部类，这种内部类的特点是：
1.静态内部类不能直接访问外部类的非静态成员，但可以通过

`new 外部类().成员 的方式访问`

2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员

3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建

`内部类 对象名= new 内部类();`

### 方法内部类
- 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。
> 一定要注意哦：由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。

### 继承
- 继承是类与类的一种关系,是一种"is a"的关系.
> 注:Java中的继承是单继承
1.子类拥有父类的方法和属性(private修饰的无效!!!)
2.实现代码复用

定义`class 子类 extends 父类`

### 方法的重写
- 如果子类对继承父类的方法不满意,是可以重写父类继承的方法的,当调用方法时会优先调用子类的方法
- 语法规则:
1.返回值类型
2.方法名
3.参数类型及个数
以上三点都要与父类继承的方法相同才叫方法的重写.

### 继承的初始化顺序
1.初始化父类再初始子类
2.先执行初始化对象中的属性,再执行构造方法中的初始化

> 父类对象 - 属性初始化 - 构造方法
> 子类对象 - 属性初始化 - 构造方法

### final关键字
- final可以修饰类、方法、属性和变量
1.final修饰类则表示该类不允许被继承
2.final修饰方法则表示该方法不允许被覆盖(重写)
3.final修饰属性:**则该类的属性不会进行隐式的初始化(类的初始化属性必须有值)或在构造方法中赋值(但只能选其一)**
4.final修饰变量,则该变量的值只能赋一次值,即变为常量

### super的使用
在对象的内部使用,可以代表父类对象
1.访问父类的属性
`super.age`
2.访问父类的方法
`super.eat()`

子类的构造的过程当中必须调用父类的构造方法,如果子类的构造方法中没有显示调用父类的构造方法,则系统默认调用父类的无参的构造方法.

如果显示的调用构造方法,必须写在子类的构造方法的第一行.

如果子类构造方法中既没有显示调用父类的构造方法,而父类又没有无参的构造方法,则编译出错!






