# java tutorial

#### java除法的结果是取整还是正常值与被除数有关。
```
(11 + 3 * 8) / 4 % 3) = 2;
// java除法的结果是取整还是正常值与被除数有关。
(11 + 3 * 8) / 4.0 % 3 = 2.75;
```

#### java的for in循环
`for (int score : scores)`

#### java创建数组
```
// 定义一个长度为5的字符串数组
String[] subjects = new String[5];

// 等价于：
String[] subjects1 = new String[]{ "Oracle", "PHP", "Linux", "Java", "HTML" };

// 等价于：
String[] subjects2 = { "Oracle", "PHP", "Linux", "Java", "HTML" };
```

#### java中定义二维数组
```
// 定义一个两行三列的二维数组并赋值
String [][] arrays = new String[2][3];
String [][] names = {{"tom","jack","mike"},{"zhangsan","lisi","wangwu"}};
```

#### 强制类型转换
`numbers[i] = (int)(Math.random() * 100);`

#### for循环中i--的写法
`for (int i = scores.length - 1; i >= 0 && count < 4; i--) {}`

## 类
- 类是模子,是用来描述对象将会拥有的特征(属性)和行为(方法).

### 类的特点:
- 类是对象(具体数据信息比如手机)的类型
- 具有相同属性和方法的一组对象的集合

### 类和对象的关系
- 类是抽象的概念,它只是我们脑海里的想象,其实客观是不存在的,仅仅是模板而已.
- 对象是一个你能够看的到,摸得着的具体实体,是客观存在的.

### 创建对象
定义：`类名 对象名 = new 类名();`
- 引用对象的属性：对象名.属性
`phone.screen = 5;// 给screen属性赋值5`
- 引用对象的方法：对象名.方法
`phone.call()`

### 给float型变量赋值时必须加f，不然会认为时double型

### 成员变量局部变量区别
1. 作用域不同
   - 局部变量的作用域仅限于定义它的方法
   - 成员变量的作用域在整个类内部都是可见的
2. 初始值不同
   - java会给成员变量一个初始值
   - java不会给局部变量赋予初始值
3. 同一个方法不允许有同名局部变量，不同方法中可以有同名局部变量
4. 两类变量同名时，局部变量具有更高的优先级

### 构造方法
定义:`public 类名(){}`
#### 无参
- 平常创建对象我门一般都new一个类，实际上这个说法不严谨，我们new的实际是一个构造方法
   >定义：`Telephone phone = new Telephone()`
- 如果我们没有指定一个无参的构造方法，系统会自动给我们自动生成一个构造方法，如果我们对系统生成的无参构造方法不满意，可以自定义一个构造方法

#### 有参
- 有参的构造方法也可以创建对象，还可以给对象中的实例变量赋初始值

### 静态变量
- 静态变量可以直接使用类名访问

### 静态方法
- 静态方法可以直接使用类名访问
- 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。

  如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。
- 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量
- 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。

### 静态初始化块
- 静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。
- 通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 staticBlock1 时并未执行静态初始化块。

### 封装的步骤
1. 修改属性的可见性：设为private
2. 创建getter/setter方法（属性的读写）
3. 在getter/setter方法中加入属性控制语句进行合法性判断
> 封装就是隐藏属性，通过方法来设置获得属性

### 包
定义：`package 包名`
- 必须放在Java源程序的第一行，包名间可以使用'.'号隔开
- 包的使用可以通过import关键字，在某个文件夹中使用其他文件夹中的类
   >`import com.imooc.music.MyClass`
- Java包的命名规范是全小写
   
   使用的时候不但可以加载某个包下所有的文件
   >`eg：com.imooc.*`
   
   也可以加载某个具体子包下的所有文件
   >`eg：com.imooc.music.*`

### 访问修饰符
访问修饰符 | 本类 | 同包 | 子类 | 其他
--- | :---: | :---: | :---: | :---:
private | ✓ | | |
默认 |  ✓ | ✓ | | |
protected | ✓ | ✓ | ✓ |
public | ✓ | ✓ | ✓ | ✓

### 内部类的主要作用如下：
1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类
2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据
3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便

#### 内部类可分为以下几种：
- 成员内部类
- 静态内部类
- 方法内部类
- 匿名内部类

### 成员内部类
> 定义:`内部类 对象名 = 外部类对象.new 内部类( );`

注意:
1. 外部类是不能直接使用内部类的成员和方法:得先创建外部类的对象,在对象.new 外部类()创建内部类,这样创建的内部类才能在外部类中的方法中使用或者访问内部类的成员变量和方法
   - `外部类 对象名 = new 外部类();`
   - `内部类 对象名 = 外部类.new 内部类();`
2. 如果外部类和内部类具有相同的成员变量或方法,内部类默认访问自己的成员变量和方法,如果想访问外部类的成员变量,可以使用this关键字
   - `Outer.this.name`

### 静态内部类是 static 修饰的内部类，这种内部类的特点是：
1. 静态内部类不能直接访问外部类的非静态成员，但可以通过
   - `new 外部类().成员 的方式访问`
2. 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
3. 创建静态内部类的对象时，不需要外部类的对象，可以直接创建
   - `内部类 对象名= new 内部类();`

### 方法内部类
- 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。
> 一定要注意哦：由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。

### 继承
- 继承是类与类的一种关系,是一种"is a"的关系.
> 注:Java中的继承是单继承
1. 子类拥有父类的方法和属性(private修饰的无效!!!)
2. 实现代码复用
> 定义`class 子类 extends 父类`

### 方法的重写
- 如果子类对继承父类的方法不满意,是可以重写父类继承的方法的,当调用方法时会优先调用子类的方法
- 语法规则:
1. 返回值类型
2. 方法名
3. 参数类型及个数
> 以上三点都要与父类继承的方法相同才叫方法的重写.

### 继承的初始化顺序
1. 初始化父类再初始子类
2. 先执行初始化对象中的属性,再执行构造方法中的初始化

> 父类对象 - 属性初始化 - 构造方法
> 子类对象 - 属性初始化 - 构造方法

### final关键字
- final可以修饰类、方法、属性和变量
1. final修饰类则表示该类不允许被继承
2. final修饰方法则表示该方法不允许被覆盖(重写)
3. final修饰属性:**则该类的属性不会进行隐式的初始化(类的初始化属性必须有值)或在构造方法中赋值(但只能选其一)**
4. final修饰变量,则该变量的值只能赋一次值,即变为常量

### super的使用
在对象的内部使用,可以代表父类对象
1. 访问父类的属性`super.age`
2. 访问父类的方法`super.eat()`

子类的构造的过程当中必须调用父类的构造方法,如果子类的构造方法中没有显示调用父类的构造方法,则系统默认调用父类的无参的构造方法.

如果显示的调用构造方法,必须写在子类的构造方法的第一行.

如果子类构造方法中既没有显示调用父类的构造方法,而父类又没有无参的构造方法,则编译出错!

### toString
在Object类里面定义toString()方法的时候返回的对象的哈希code码（对象地址字符串）

可以通过重写toString()方法分表示出对象的属性

### equals
比较的是对象的引用是否指向同一块内存地址
> getClass:可以得到一个类对象（当我们new一个类的时候得到的对象是类的对象），如果这个对象调用getClass方法得到的是类对象
> 类对象描述的是类的代码信息：类有那些属性、它是什么类型、变量名是什么，它有哪些方法、方法名是什么、方法里面的代码是什么
> 类的对象我们关注的是对象属性值的信息或者说这个对象的数据信息，比如说这个对象有个age属性，它是18呢还是20？我们更关注的是数据信息

`getClass() != obj.getClass`:两个类对象的类型是否相同

### 多态
**在使用多态的时候两个类必须是多态的关系！**
1. 引用的多态
   - 父类的引用可以指向本类的对象
   - 父类的引用可以指向子类的对象
   - `子类的对象不能引用父类的对象`

2. 方法的多态
   - 创建本类对象时，调用的方法为本类的方法
   - 创建子类对象时，调用的方法为子类重写的方法或者继承的方法
> 注意：不能通过父类的引用调用子类独有的方法！

### 引用类型转化
1. 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换
2. 向下类型转换（强制类型转换），是大类型到小类型
3. 强制类型转换的时候是有风险的，这时候我们可以使用instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题

> 注意下面的animal引用的是Dog类的对象

通常配合if来使用`if(animal instanceof Dog)`

### 抽象类abstract
定义：`抽象类前使用abstract关键字修饰，则该类为抽象类`
1. 在某些情况下，某个父类只是知道其子类应该包含怎么怎样的方法，但无法准确知道这些子类如何实现这些方法。
2. 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。

作用：不关注实现细节，但是要约束子类必须实现某些方法必须拥有那些特征。

规则：
1. abstract定义抽象类
2. abstract定义抽象方法，只有声明，不需要实现
3. 包含抽象方法的类是抽象类
4. 抽象类中可以包含普通的方法，也可以没有抽象方法
5. 抽象类不能直接创建，可以定义引用变量

### 接口
1. 接口的概念
   - 接口可以理解为一种特殊的类，它的内部全部都是常量和公共的抽象方法组成
   - 如果说类是一种具体的实现体，那么接口就是类必须要遵守的规范，接口并不关心类的内部数据，也不关心这些类里的方法的实现细节，它只规定这些类必须提供并实现某些方法。满足我们的实际需要。
   - 换句话说接口其实是一种规范，它是来约束类的。
2. 接口的定义
   - 和类定义不同，定义接口不在使用class关键字，而是使用interface关键字。
```
[修饰符] interface 接口名 [extends 父接口1, 父接口2...] {
  零到多个常量定义。。。
  零到多个抽象方法定义。。。
}
```
注意：
- 接口通常是用来被继承、被实现的，修饰符一般建议用**public**，不能使用**private**和**protected**修饰接口
- 方法体里有抽象方法，所以接口也是抽象的，可以在interface

### UML
Unified Modeling Language(UML):同一建模语言或标准建模语言，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持

常用UML图
1. 用例图（The Use Case Diagram）：能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求等信息。
2. 序列图（The Sequence Diagram）：用于按照交互发生的一系列顺序，显示对象之间的这些交互。
3. 类图（The Class Diagram）：UML类图，业务逻辑和所有支持结构一同被用于定义全部的代码结构。（通常用于描述类与类之间的关系，类的属性功能）

### 达达租车系统
- mysql版：http://www.imooc.com/article/20387
- java中printf中用法详解：https://www.cnblogs.com/seakt/p/4478045.html

### 异常
Throwable：Error，Exception
  1. Error：系统错误（它出现了，说明程序彻底挂了）
     - VirtualMachineError（虚拟机错误）
     - ThreadDeath（线程死锁）
  2. Exception：编码、环境、用户操作输入出现问题
     1. RuntimeException(非检查异常)主要指的是：
        - NullPointException(空指针异常);
        - ArrayIndexOutOfBoundsException(数组下标越界异常);
        - ClassCastException(类型转换异常);
        - ArithmeticException(算术异常);
        - IllegalAccessException(安全权限异常);
     2. CheckException(检查异常)：需要手动添加捕获和处理语句
        - IOException（文件异常）
        - SQLException（连接异常）

### 抛出异常及自定义异常
- throw：将产生的异常抛出（动作）
- throws：声明将要抛出何种类型的异常，可以是多条异常，每个类型的异常中间用逗号隔开（声明）
```
public void 方法名(参数列表) throws 异常列表 {
  //调用会抛出异常的方法或者：throw new Exception();
}
```
![java中异常抛出](./assets/java中异常抛出.png 'java中异常抛出')
> divide方法中申明了一个异常，当two为0是，抛出一个异常。

> 可以处理：如果下面的compute方法调用了divide方法就要添加try catch语句去尝试捕获这个异常

> 不能处理：或者像右侧一样添加throws声明来将异常抛出给更上一层调用者去处理

### java当中的异常种类
![java当中的异常种类](./assets/java当中的异常种类.jpg 'java当中的异常种类')

### 自定义异常:必须继承java标准类库中意思相近的异常或者直接继承所有异常的基类（Exception）
`class 自定义异常类 extends 异常类型{}`

### 实际应用中的经验与总结
1. 处理运行时异常时，采用优化代码用逻辑去合理规避同时辅助try-catch处理
2. 在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常 
3. 对于不确定的代码，也可以加上try-catch，处理潜在的异常 
4. 尽量去处理异常，切记只是简单的调用printStackTrace（）去打印——比如业务回滚
5. 具体如何处理异常，要根据不同的业务需求和异常类型去决定
6. 尽量添加finally语句块去释放占用的资源

### String
`String s1 = "imooc";`
`String s2 = new String("imooc");`
- 对于多次出现的字符串常量，Java编译程序只创建一次，每次创建一个常量字符串的时候，其实是隐式调用了new String，String s2存放了字符串对象的引用
- 一旦一个字符串在内存中创建了，则这个字符串将不可改变。
- s1 = "欢迎来到：" + s1; 改变了字符串 s1 ，其实质是创建了新的字符串对象

### String类常用方法
1. int length() 返回当前字符串的长度
2. int indexOf(int ch) 查找ch字符在该字符串中第一次出现的位置
3. int indexOf(String str) 查找str子字符串在该字符串中第一次出现的位置
4. int lastIndexOf(int ch) 查找ch字符在该字符串中最后一次出现的位置
5. int lastIndexOf(String str) 查找str子字符串在该字符串中最后一次出现的位置
6. String substring(int beginIndex) 获取从beginIndex位置开始到结束的子字符串
7. String substring(int beginIndex, int endIndex) 获取从beginIndex位置开始到endIndex位置的子字符串
8. String trim() 返回去除了前后空格的字符串
9. boolean equals(Object obj) 将该字符串与制定对象比较，返回true或false
10. String toLowerCase() 将字符串转换为小写
11. String toUpperCase() 将字符串转换为大写
12. char charAt(int index) 获取字符串中指定位置的字符
13. String[] split(String regex, int limit) 将字符串分割为子字符串，返回字符串数组
14. byte[] getBytes() 将该字符串转换为byte数组

字节是计算机存储信息的基本单位，1个字节等于8位，gbk编码中1个汉字字符存储需要2个字节，1个英文字符存储需要 1 个字节。
- 所以我们看到上面的程序运行结果中，每个汉字对应两个字节值，如“学”对应 “-47 -89” ，而英文字母 “J” 对应 “74” 。
- 同时，我们还发现汉字对应的字节值为负数，原因在于每个字节是 8 位，最大值不能超过 127，而汉字转换为字节后超过 127，如果超过就会溢出，以负数的形式显示。

Java采用unicode来表示字符，java中的一个char是2个字节，一个中文或英文字符的unicode编码都占2个字节，但如果采用其他编码方式，一个字符占用的字节数则各不相同。
- 在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉子字符存储需要2个字节。
- 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。
- 在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。
- 在UTF-32编码中，世界上任何字符的存储都需要4个字节。

### StringBuilder类常用方法
- 频繁操作字符串时，会额外产生很多临时变量。使用StringBuilder和StringBuffer就可以避免这个问题。
- 两者基本相似，不同之处，StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用**StringBuilder**类。
1. str.append("abc") 追加字符串 abc
2. str.toString();转换为string对象
3. str.insert(num,"abc")在字符串num位置(从左到右数num个字符后，添加)添加 abc 内容
4. str.length()获取字符的长度
